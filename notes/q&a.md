## 问题答案收集

### HTTP状态码
```js
/**

200和304实现缓存的区别:
    - 200是强缓
    - 304是协商缓存
讲讲304,301和302的区别:
    - 304 发送附带条件请求时不满足条件返回,与重定向无关,如:If-Modified-since
    - 301 永久重定向
    - 302 临时重定向
303,307是什么:
    - 303 与302相似,只是它希望客户端在请求一个URI的时候,能通过GET方法重定向到另外一个URI上
    - 307 与302类似,只是它强制使用POST方法
401和403的区别
    - 401 请求需要认证
    - 403 请求的对应资源禁止被访问
如何避免301跳转https
    -?  alias ?xxxx ?????


浏览器缓存机制缓存机制，协商缓存?什么时候用哪个 :
    - 强缓 1.0 Expires/ 1.1 Cache-Control
    - 协商缓存Last-Modified / Etag
    - 相同点,如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据
    - 不同点,强缓存不发请求到服务器，协商缓存会发请求到服务器

HTTP1.1中Etg和f-None-Match哪个权重比较大
    - 本题貌似有问题, Etag 和if-None-Match是同一个东西,只是一个是输入响应头,一个属于请求头,待其他人确    认??

tcp ip分层
    - 应用层:
        + 为应用提供各种服务,如http,ftp,dns,smtp等
    - 传输层:
        + 为应用层实体提供端对端的通信功能保证数据包的顺序传送及数据的完整性
    - 网络层
        + 主要解决主机到主机的通信问题,IP协议是网际互连层最重要的协议
    - 数据链路层 |
                | ==> 主要监视数据在主机和网络之间的交换
    - 物理层    |  

了解TCP吗:
    - TCP输入TCP/ip中的传输层中其中一种协议,
HTTP各版本比较
HTTP1.0和HTTP1.1相关我让你听
    - Transfer-Encoding,cache-control,keep-alive在1.1中新增的
HTTPS: 
    - HTTPS是http over SSL,他的安全性由SSL协议实现的,SSL是记录协议方便扩展,TLS是它的子协议
    - SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数   据进行加密，并增加自己的SSL头。

HTTP2.0的优势
    - 多路复用,一个链接实现并行请求
    - 二进制传输高效紧凑,报头压缩,降低开销
    - 服务器主动推送减少请求延迟
    - 默认加密

*/
```




### js &　框架

```js
/**
 * 
 * 了解web移动开发吗，移动端适配方案有哪些
 *      - 在head 设置width=device-width的viewport‘, 在css中使用px
 *      - 在适当的场景使用flex布局，或者配合vw进行自适应
 *      - 在跨设备类型的时候（pc <-> 手机 <-> 平板）使用媒体查询
 *      - 在跨设备类型如果交互差异太大的情况，考虑分开项目开发
 *
 * amd，cmd规范
 *      - AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行
 *      - AMD的代表requiJS,CMD的代表 sea.js
 * 
 * react,vue 区别,如何选择技术栈
 *      - react16.8之前 和vue的 vdom差不多,vue还做过diff的优化,react16.8以后新增了fiber,逼格明显增*        高,同时利用requestIdleCallback对 update 分批分片更新,性能更好,技术点也很新颖;vue本身都是在
 *        react和ng基础上诞生的更轻便的库,它所具有的功能在ng和react中都有
 *      - 技术选择看社区对依赖的支持和成熟度,轻应用优先选vue
 * 
 * react的virtual DOM和Diff算法
 *      - vdom 都是js对象,用来描述dom对象
 *      - diff主要采用先序深度优先遍历,找出异常抛出一个patch进行更新
 * react的事件绑定和原生有什么区别吗
 *      - react把合成时间机制,事件都委托到document上,通过冒泡触发,原生的是直接绑定
 * 
 * React的生命周期
 *      - v15 :willMount,render,didMount,(WillReceiveProps),shouldUpdate?,willUpdate,
 *             render,didupdate,willUnmount
 *      - v16 :getDerivedStateFromProps,render(update dom and refs),didMount;
 *              (new props,setState,forceupdate) ,getDerivedStateFromProps,shouldUpdate?,
 *              render ,didUpdate,willUnmount
 *      - 注:废弃的:willMount,willReceiveProps,willUpdate.
 * 
 * redux原理讲讲
 *      - redux 是对函数式编程的最佳实践,了解函数式编程可忽略
 *      - store->container,currentState -> _value,action->f,reducer -> map,middleware -> io
 *        functor
 * 
 * vue数组怎么实现绑定的
 *      - 重写数组原型链方法,单独对数组写个方法处理
 *      - v3.以后改用Proxy 就不用这么麻烦了
 * 
 * Vue的生命周期
 *      - beforeCreate,created,beforeMount,mounted,beforeUpdate,updated,beforeDestroy,     *        destroyed
 * vuex的状态管理的原理是什么
 *      - 它借鉴了Flux redux的思想,在全局创建一个Store,数据为state,对于state的修改只能通过store内部
 *        的方法commit来直接修改;它是vue的插件,将其挂在所有的组件上,每个组件都可以访问作为属性
 * 
 * vue-router不能解决情况和边界情况
 * 
 * mvvm，mvc，mvp区别
 *      - mvc是起源与服务端,request->C->M->V;CV过于紧密
 *      - mvp 是mvc的改良版,M,V,P是双向通信的;Presenter完全把Model和View进行了分离，主要的程序逻辑在*        Presenter里实现
 *        ,P与具体的V没有直接关联,而是通过定义好的接口进行交互,从而使得在变更V的时候保持P不变,这样就可以
 *        重用,不仅如此还可以对V编写测试用例
 *      - mvvm:M-V-VM,该架构直接将M,V分离,不会相互影响;主要逻辑在VM层,它和M-V双向绑定
 * 
 * boostrap的底层原理
 *      - 主要是对常用样式的封装,借助媒体查询和百分比实现响应式
 * 垃圾回收机制
 *      - 在浏览器中主要通过标记清除方法来回收垃圾;NodeJs 中主要通过分代回收、Scavenge、标记清除、
 *        增量标记等算法来回收垃圾
 * 
 * ES6用过吗，新增了那些东西，你用到过什么 symbol
 * JS设计模式有哪些
 *      - 职责连模式:由一个超类实现下个实例的方法和传递逻辑,同时创建一个abstract的handle方法,在多个子*        类中去实现
 *      - 组合模式:将对象组成树状层次结构,对每个对象统一的接口访问,具体设计中可以让树枝有添加节点功能,叶 *        子节点没有该功能
 *      - 策略模式:是对各种算法的组织策略,不直接写算法,提供一个方案如使用算法;具体设计一般是先实现几个具*        体类,里面实现了具体的算法,在创建一个环境类,实现对当前具体策略的设定和公开的调用接口
        -...,目前熟悉的就以上,当然还有以下很基础的就不细说了
        - 观察者模式,单例模式
        - 代理,命令还没研究
 * 内存泄露的排除定位和解决方法
 * 
*/

```

## nodejs了解多少
```js
/**
 * 
 * Nodejs的线程管理
 *  - 由worker_threads包实现,里面包含Worker,parentPort,isMainThreads,workerData
 *  - Worker: 用于在主线程中创建子线程。第一个参数为 filename，表示子线程执行的入口。
 *  - isMainThread: 是否是主线程，源码中是通过 threadId === 0 进行判断的。 
 *  - parentPort: 在 worker 线程里是表示父进程的 MessagePort 类型的对象，在主线程里为 null
 *  - workerData: 用于在主进程中向子进程传递数据（data 副本）
 * 
 * 线程的哪些资源共享，哪些资源不共享
 *  - 共享的有 堆,进程id
 *  - 独有的有:栈,寄存器
 * 
 * pm2除了监控还能干什么，如何实现
 *  - 做静态服务器
 *  - 源码映射
 *  - 日志管理
 * 前端监控，pm2，如果我服务器挂了，如何快速发现并且定位错误
 *  - 监控异常,邮件提醒
 * 
 * IO多路复用
 *  - 多路复用是指多个网络IO复用一个或者少量的线程来处理socket,处理方案有select,epoll
 *  - select 通过轮循检查文件描述符设置的标志位进行判断,单个进程有1024个描述符的限制
 *  - epoll 在内核空间设置了epoll API,当哪个改变了直接通知对应的用户空间的epoll,相当于
 *    维护了一个Map,不用遍历,效率很高
 * Linux命令用的多吗，怎么样进行进程间通信
 *  - 已知的 管道（pipe）,流管道(s_pipe)和有名管道（FIFO）
 *  - 未知的 5 种,后期研究
 * websocket协议，nodejs中有哪些实现了这个协议
 *  - websocket是持久化协议,由于http1无法持久化不能服务端主动推送二而诞生的
 *  - 实现有:socket.io
 * 
 * 
 * koa generator能讲一下吗
 *  - 这个是koa1的东西,没有了解,但它核心就是es6的generator函数,
 *    中间件用next组织在一起形成一个洋葱模型的流程
 * 
 * 
 * Socks5代理是如何实现的，读过协议吗
 *  - 主要通过代理机对客户机进行认证,作为中间层为目标机和客户机做数据中转
 *  - 具体步骤有: 
 *      + 客户机请求服务器,请求服务器告知 socks版本和指定认证方法
 *      + 服务端收到数据后,告知客户端支持的 版本和 认证方式(免密或者加密)
 *      + 客户机按照服务端给的认证方式向服务器发正式请求
 *      + 服务端收到请求后链接目标服务器
 *      + 服务开始转发客户机和目标机直接的流量
 * 酸酸是如何实现穿墙的
 *  - 主要还是在在本机和vps机实现共同的加密解密技术,加密的报文在GFW阶段无法
 *    识别就放它一马
 *  - 其核心是 加密技术 和 socks代理
 * 
 * 
 * 
*/
```



### 算法：反转二叉树以及时间复杂度
```js
/**
 * 
 * 
 * 快排和冒泡原理
 *      - 快排:用分而治之的思想加上递归实现,具体操作是找一个基准值把当前数组进行分割,大于它的放在右边,小于它的放在左边
 *      - 冒泡:从左到右和当前值做对比,找出最小的一个放在当前位置
 * 链表找环
 *      - 用一个数组或者hash来记录链表的每个节点,同一个节点遍历出现了两次说明就是交叉点
 * 图片压缩的原理
 *      - 使用最优二叉树实现
 * JS的全排列
 * 如何处理高并发的情况下，用户顺序问题
 *      - 异步事件队列
 * 如何在上亿规模的数据中找到最大的一个数
 *      - 考虑数据结构怎么设计,数据分区,每个区最好都排序
 *      - 当然最好是数据已经排过序了,最优办法看其他人方案 ?
 * 排序的几种方法知道吗，是如何实现的
 *      - 常见的有:冒泡,选择,快排,插入
 * 栈和队列有什么区别，具体的应用场景
 *      - 都是链表,只是定义和操作方式不同,栈是先进后出,队列是先进先出
 *      - 应用场景,栈的有函数执行栈,编译器对四则运算符号的处理;队列有事件队列
 * hashmap原理
 *      - 将数据以key-value的对应形式存在表里(对应关系叫散列函数 h(key));本身是一个查找算法,存的时候已经知道了存储关系,取*        值的时候也不需要额外的计算
 * 
*/
```

### 其他